Made by Quincy Ryan. Based on Butner's syllabus and study guides. Some examples generated by GPT, but generally written by Q. 
Structured at different pace because conceptual knowledge is assumed. 

**Guide Checklist**
- [ ] Intro
	- [ ] Why
	- [ ] History / comparison
	- [ ] Set up
	- [ ] General difference
		- [ ] Create C++ / C comparison
- [ ] Tools / Implementation
	- [x] S1: Basics: Vars and printing/getting
	- [x] S2: Strings
	- [ ] S3: Functions 
		- [ ] Basics
		- [ ] Advanced
	- [ ] S4: Importing
	- [x] S5: Logic: if, comparison, Lops, Switch
	- [ ] S6: Loops 
	- [ ] S7: Containers
	- [ ] S8: File reading / writing / web.  
	- [ ] S9: Exceptions / errors
	- [ ] S10: Classes / OOP
	- [ ] S11: Multi-programs
	- [ ] S12: algs / data structures
- [ ] Additional: Where to go next. 
- [ ] Example Mega program: 
	- [ ] C++ program that implements all features
	- [ ] Python program that implements all features 


### Why another python guide:
Other guides...
- Do not give context meaning behind the switch. 
- Serve as a general intro to programming / CS problem solving.
  - In contrast, this is meant to build the vocabulary and filter out redundancy for someone who already has programming experience.

This guide is meant to be:
- aimed at people who already know C / C++ and want/need to learn Python asap
- a reference without bloat
- under 7 pages
- a way to teach myself Python

This guide will not cover:
- Problem solving / computational thought
- OOP concepts

If SAing with Professor Butner, it's presumed you're familiar with OOP from taking ECS 36B.


# Intro to Python
### Precursors
C was developed
- Much more abstract and readable than alternatives
- Still pretty readable, relatively speaking
- Not very "featured" 

Then C++ was developed
- More featured: 
	- OOP or "C with classes"
	- try / throw errors
	- Built-in data structures / containers
	- Huge innovation, More "there" [what does that mean? -r], less bottom up implementation

The current (eternal) state of C/C++:
- You have to manage memory
- C++ suffers from "feature debt" and is often said to be *over featured* or bloated. There are so many clever trick and features, but two people could use them so differently that their code is almost incomprehensible to each other.

These are still great languages. They are complex but very popular. They are industry standard, and *far faster* than Python. I personally love them. Programming feels wrong without a `;` to me. I'm working on it. 

Python was designed to make programming more accessible, easier, and faster to code. 

## When should you use one over the other? 
### Python
- Task automation (move files, rename files, scrape things from the internet)
- Prototyping a more complex program: 
- Literate programming (see more)
- AI / ML : 
	- Python is the gold standard
	- Generally optimized: (see mojo)
- Data science
- **Because you are sick of the right angles and boxes that confine the world**, you want something simple and warm to get something meaningful done ASAP.

### C / C++ 
- Things that need to run quickly (graphics, massive number crunching, operating systems)
- Things that need to run many many many times
- Thing that need to run on simple / old hardware
- **Because you crave structure / specificity in a vague, gooey world**.
You don't mind taking some extra time to make what you're doing really good, really fast, and maybe even poetic. 

## Getting started
Python is an interpreted language, meaning it's run the same way interactively in a command prompt as it is run from a script. *You do not need to compile anything.*

Some starting differences:
- Drop the `;` at the ends of statements
- Comment with `# comment` instead of `// comment`
- Python gets its structure from tabs/indents instead of from braces like C/C++
- You don't need to explicitly specify a `main()` function (if none is specified, it will treat the file somewhat like a shell script, interpreting one line at a time)
- No `#include <stdlib>`, already included. File is basically set up, and you don't need to add anything unless you want to add some additional features through modules
- Python sort of runs like a debugger already. Errors wont be found until they occur at runtime. (no compile time errors)

IDEs: 
- IDLE: Default Python IDE
- PyCharm: JetBrains' more "built out" IDE
- VSCode: if you use it already
- Jupyter Notebook: for documentation / words mixed with programming (see literate programming)

Here's how the interpreter looks:
```
>>> print("Hello world!")
Hello world!
>>> 3 + 7
10
>>> import math
>>> math.pow(2, 3)
8
>>> 
```
Here's how a Python file might look:
```py
import math

# Here's a comment!
print("Hello world!")
print(3 + 7)
print(f'2^3 = {math.pow(2, 3)}')
```
And then you can run it like this:
```
$ python3 helloworld.py
Hello world!
10
2^3 = 8
```
For comparison, here's how something similar might look in C:
```c
#include <stdio.h>
#include <math.h>

int main() {
	// Here's a comment!
	printf("Hello world!\n");
	printf("%d\n", 3+7);
	printf("2^3 = %.f\n", pow(2, 3));
}
```
And you run it like this:
```
$ gcc -o helloworld helloworld.c
$ ./helloworld
```

# Tools / Implementation. 
## Section 1: Basics: vars and printing/getting
**In this section**: 
- vars
	- Variable assignment 
	- Type hinting
	- How to use variables in expressions 
- Printing to command line, getting command line input
- Type conversion
- Arithmetic operators. 

Python is **dynamically typed**, so we do not need to specific the data type. 
We *can* **type hint** which makes our intentions clearer, and may (or may not) result in more optimized code. (See the "mojo" language). 

```python
# Variable assignment
x = 5
y = z = 10 	# Set both y and z to 10
a, b = 0, 1 	# Set a=0 and b=1

# Type hinting
var1: int = 1
str1: str = "Hello reader"

# Using variables in expression
result = x + y  # not really different from C; biggest difference is there's no result++ (just result += 1)
```

**Interacting with command line*
```python
# Getting input from command line
user_input = input("Give me a number: ")

# Printing to command line
print(str(user_input))		# Must cast to string because print() takes string input
```

**Arithmetic operators**: Same as C/C++, except now we have floor division `//`
```python
result = 10 + 5  # Addition
result = 10 - 5  # Subtraction
result = 10 * 5  # Multiplication
result = 10 / 5  # Division
result = 10 // 3 # Floor Division, yields 3 in this case
result = 10 % 3  # Modulus, yields 1 in this case
```


**Type conversion**: Note that bools are `True` and `False`, capitalized.
```python
int_value = int("123")  	# Convert string to integer (123)
float_value = float("123.45")  	# Convert string to float (123.45)
str_value = str(123)  		# Convert integer to string ("123")
bool_value = bool(1)  		# Convert integer to boolean (True)
```

## Section 2: Strings
**In this section**: 
- String operations
- String access
	- Characters
	- Substrings / slicing
- String class members / operations

Single quotes are the same as double quotes in Python. `'a'` is not categorically *different* from `"a"` like it would be in C --- they're both just strings. Python doesn't even have a character or `char` type. All single characters are just strings of length 1.

### String Operations
```python
string1 = "Hello"
string2 = "World"
concatenated_string = string1 + " " + string2  	# Results in 'Hello World'
multiplied_string = string1 * 3  		# Results in 'HelloHelloHello'

# String formatting
name = "Alice"
age = 14
formatted_string = f"{name} is {age} years old."

# string length:
length = len(name) 				# len("Alice") is 5
```

String access is similar, but now we can do negative indexing, to access characters at the end of the string without finding the string length beforehand. 
```python
mystring = "Hello world!"

# Positive indexing
first_char = mystring[0]			# "H"
last_char = mystring[len(mystring) - 1]		# "!"

# Negative indexing: index 0 indicates the first char, so -1 indicates the last char
also_last_char = mystring[-1]			# Last char: "!"
also_first_char = mystring[-len(string)]	# "H"

# Accessing the middle of a string
middle_char = string[len(string) // 2]  # For odd-length strings, gets the middle character
```
**Index Out of Bounds:** Throws an error (at runtime; there is no "compile" time)

### String Slicing using `:`
This is how you specify substrings:
```python
greeting = "Hello, World!"
copy_of_greeting = greeting[:]  	# Copies the entire string
reversed_greeting = greeting[::-1]  	# Reverses the string
first_five = greeting[:5]  		# 'Hello'
last_four = greeting[-4:]  		# 'rld!'
substring = greeting[7:10]  		# 'Wor'

out_of_bounds_slice = greeting[20:]  	# Returns an empty string if index is out of bounds
```

### String operations
These operations return bool values:
```python
sample = "hello world!"
ends_with = sample.endswith("world!")	# True 
starts_with = sample.startswith("he") 	# True
is_alpha = sample.isalpha() 		# False because of the presence of "!"
is_lower = sample.islower()  		# True (ignore the punctuation)
is_upper = sample.isupper()  		# False

whitespace = "\t\t\n\n"
is_space = whitespace.isspace()  	# True

mixed = "123abc"
is_alnum = mixed.isalnum()  		# True
is_digit = digits.isdigit()  		# False because of the presence of "abc"
```

These operations return string values:
```python
sample = "   i am Mixed CASE!!   ")
lower_case = sample.lower()  		# "   i am mixed case!!   "
upper_case = sample.upper()  		# "   I AM MIXED CASE!!   "
stripped = sample.strip()		# "i am Mixed CASE!!"
left_stripped = sample.lstrip()		# "i am Mixed CASE!!   "
right_stripped = sample.rstrip()	# "   i am Mixed CASE!!"
# And you can stack them too:
funsies = sample.upper().rstrip()	# "   I AM MIXED CASE!!"
```


## Section 3: Functions
- Basic
	- Define functions
	- Call function. 
	- Parameter names, arguments: what matters when calling a function: "Do the names of parameters and arguments matter when calling a function? If not what does matter"
	- What is the difference between returning a value and printing a value? - not sure if valuable
- Advanced

**Advanced**
- function call
- Function Def
	- Overloading
		- Optional
		- Any number of positional
	- Functions with Functions as args. 

1. Be able to write functions that take optional arguments.
2. Be able to write functions that take any number of positional arguments
3. Be able to pass an iterable to a function that takes any number of positional arguments.
4. Be comfortable with functions that take other functions as arguments
    1. For example the functions sort, min, and max all take an optional parameter called key. Key is a function that is applied to each element in the iterable and the value returned from it is used in the actual comparisons. If we did max(-25, 5, 12, 8, key = abs) the value we would get back is -25 as has the largest absolute value of the numbers.




## Section 4: Importing Modules

Like `#include` or namespaces. 
Modules
Can define the way we use / call these functions

1. Be able to import a module
    1. Import the math module
    2. Import the random module
2. Be able to import a subcomponent of a module
    3. Import the log function from the math module
    4. Import the randint function from the random module

## Section 5: If, logic, comparison, switch
**In this section**:
- Boolean logic / comparisons 
- if, else, elif
	- implementation
- Switch statements

**Boolean logic**: `and` `or` `not` (No xor, nand, nor, etc. Can be implemented w functions)
**comparison**: `==` `!=` `<` `>` `<=` `>=`. 
Always good to use `(.)` to be safe. Must reiterate comparison when connected by logic like in C/C++. 

**If trees**:
- Conditions are not in `(.)`, end of condition `:`
- Scope is `    ` (4 spaces / tab) 
- `if`
- `elif` instead of `else if` in c
- `else:` doesn't require condition (like c and all others)

```python
def classify_grade(score):
    if score >= 90: # nesting
	    if score >= 96: 
		    return "A+"
		elif (score < 96 or score > 93): # multiple conditions
			return "A"
		else: 
			return "A-"
        return "A"
    elif score >= 80:
	    return "B"
    else: 
	    return "C or below" # dont @ me I'm lazy
    

```

Bonus: **Switch statements**: 
replaced by `match` + `case` keywords in python 3.10 and above
```python
match grade: 
	case "passing": 
		print("good job!")
	case "failed":
		print("Summer classes")
	case _: # default statment
		print("Don't know yet")
```


## Section 6: Loops

In this section: 
- Loop fundamentals
	- For loops
	- While loops
	- Nesting loops / Scope
- Loop tools
	- Enumeration
	- Zip
	- Break
	- Continue


## Section 7: Containers
In this section
- containers
	- Lists 
	- Tuples
	- Dictionaries
- Use for each
	- Getting
	- Setting
	- Looping / iteration. 

## Section 8: files
In this:
- getting from files
- Writing to files
- Web scraping? 

## Section 9: Exceptions / errors 

## Section 10: Classes / OOP

## Section 11: Multi file programs

## Section 12: Algs / data structures. 

# Additional / where to go next

For UI

For data science

For ML / neural networks

For games


From GPT 
1. **Debugging Techniques**
    - Understanding Python's error messages.
    - Using debugging tools like `pdb` (Python Debugger).
2. **Testing**
    
    - Writing unit tests using `unittest` or `pytest`.
    - Integration of tests into a development workflow.
3. **Virtual Environments**
    
    - Managing project dependencies using `venv` or `conda`.
    - Best practices for isolating project setups.
4. **Package Management**
    
    - Using `pip` for installing and managing packages.
    - Introduction to `pipenv` for managing project setups and dependencies.
5. **Data Handling**
    
    - Introduction to `pandas` for data manipulation.
    - Using `numpy` for numerical data.
6. **Concurrency and Parallelism**
    
    - Understanding `threading` and `multiprocessing`.
    - Using `asyncio` for asynchronous programming.
7. **Decorators and Generators**
    
    - Deep dive into advanced Python functions like decorators and generators.
8. **Graphical User Interfaces (GUI)**
    
    - Basics of creating applications with `tkinter` or `PyQt`.
9. **Web Development**
    
    - Introduction to web frameworks like Flask or Django.
10. **Best Practices**
    
    - Writing clean and maintainable Python code.
    - Understanding Pythonic principles.

